#! /bin/sh

PROGNAME="$(basename "$0")"

usage() {
    printf "Usage: %s [-r] [-u]" "$PROGNAME"                      >&2
    print  "  -r    refresh contents, dont mess with .ORIG files" >&2
    print  "  -u    uninstall"                                    >&2
    exit 1
}

log() {
    printf "%s: %s\n" "$PROGNAME" "$@"
}

error() {
    printf "%s: %s\n" "$PROGNAME" "$@"
    exit 1
}

INSTALLOP=install
DESTDIR=$HOME
DEBUG=false
REFRESH=false
while getopts "Drud:" o; do
    case "${o}" in
        u)  INSTALLOP=uninstall   ;;
        d)  DESTDIR=$OPTARG       ;;
        r)  REFRESH=true          ;;
        D)  DEBUG=true            ;;
        *)  usage                 ;;
    esac
done
shift $((OPTIND-1))
$DEBUG && INSTALLOP='echo'

HERE="$(cd "$(dirname "$0")" && pwd)"
SYS="$(uname)"

#
# Basic checks
#
case "$SYS" in
    Linux)  STATFMT='--format' ;;
    Darwin) STATFMT='-f'       ;;
    *)      error Unknown system "$SYS" ;;
esac
if [ "$(stat $STATFMT %d "$DESTDIR")" -ne "$(stat $STATFMT %d "$HERE")" ]
then
    error repo needs to install in the same file system
fi
getInode() { stat $STATFMT %i "$1" 2>&- ; }

#
# Utilities to (un)install
#
install() {
    if [ -e "$2" ] ; then
        $REFRESH && {
            log skip "$2"
            return
        }
        mv "$2" "$2".ORIG # backup existing
    fi
    if [ -d "$1" ] ; then
        ln -s -f "$1" "$2"
    else
        ln -f "$1" "$2"
    fi
    log "link $2 to $1"
}

uninstall() {
    if { [ -f "$2" ] && [ "$(getInode "$2")" = "$(getInode "$1")"  ] ; } ||
       { [ -d "$2" ] && [ "$(readlink "$2")" = "$1" ] ; }
    then
        rm -f "$2"
        if [ -e "$2".ORIG ] ; then
            mv "$2".ORIG "$2"
        fi
        log "unlink $2 from $1"
    fi
}

#
# make shellcheck happy
#
install   "$HERE"/no-op "$DESTDIR"/.no-op >/dev/null 2>&1
uninstall "$HERE"/no-op "$DESTDIR"/.no-op >/dev/null 2>&1

#
# Protect the repo first
#
pre-commit install --install-hooks

#
# dotFiles
#
# setup defaults initilization
printf '(defconst emacs-rc-dir "%s/emacs")\n' "$HERE" > dot.emacs-rc-dir.el
{
    printf 'export ZDOTDIR="%s";\n'   "${ZDOTDIR:="$DESTDIR"}"
    # shellcheck disable=SC2016
    printf 'export ZDOTDIR_LOCAL="${ZDOTDIR_LOCAL:-"%s"}";\n' \
           "${HERE}/zshell"
    printf 'setopt NO_NOMATCH;'
} > dot.zinit

mkdir -p "$DESTDIR"
for i in ./dot.* ; do
    ${INSTALLOP} "$HERE"/"$i" "$DESTDIR"/"${i/.\/dot/}"
done

mkdir -p "$DESTDIR/.config"
for i in ./dotConfig/* ; do
    ${INSTALLOP} "$HERE"/"${i/.\//}" "$DESTDIR"/"${i/.\/dotConfig/.config}"
done

#
# This is a one-off
#
mkdir -p "$DESTDIR"/.emacs.d/lib
${INSTALLOP} "$HERE"/dotEmacs.d/lib/fonts "$DESTDIR"/.emacs.d/lib/fonts

#
# These dot files contain configs and secrets.  Only link the 
# configs individually.
#
find ./safeLink/dot.* -type f | while read -r fil ; do
    rfil="${fil/.\/safeLink\/dot/}"
    mkdir -p "$(dirname "$DESTDIR/$rfil")"
    ${INSTALLOP} "$HERE/${fil/.\//}" "$DESTDIR/$rfil"
done

#
# binaries
#
mkdir -p "$DESTDIR"/bin
for i in "$HERE"/bin/*
do
    ${INSTALLOP} "$i" "$DESTDIR"/bin/"$(basename "$i")"
done

#
# Fonts
#
# brew install
#   font-alegreya
#   font-alegreya-sans-sc
#   font-alegreya-sans
#   font-alegreya-sc
#   font-anonymous-pro
#   font-atkinson-hyperlegible
#   font-awesome-terminal-fonts
#   font-fontawesome
#   font-hack-nerd-font
#   font-lato
#   font-source-sans-3
#   font-source-serif-4
#   font-source-code-pro
#

case "$SYS" in
    Linux)  ;;
    Darwin) brew bundle install ;;
esac

exit
